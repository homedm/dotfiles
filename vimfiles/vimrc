" Last Change: 29/03/2019 - 22:34:48.
" Maintainer: Watanabe Taichi <weasel.wt(at)outlook.com>

" ### Initialization ### {{{
set nocompatible
set all&
augroup MyAutoCmd
        autocmd!
augroup END

" in shell setting file, for example .bashrc or .cshrc
" setenv $VIMRUNTIME ~/vim/vim/runtime
set runtimepath+=~/.vim

" japanese help
set helplang=en,ja

if has('vim_starting')
    set encoding=utf-8
    scriptencoding=utf-8
endif

" windows上でもunix形式のend-of-lineを使う
" ファイル名内の'\'をスラッシュに置換する
set viewoptions=unix,slash

" disable indent plugin each filetype
filetype plugin indent off
set t_Co=256

" enable syntax highlight
syntax on
set synmaxcol=200
set cmdheight=2
" faster redraw
set lazyredraw
set ttyfast
" Keyword highlight ex. TODO:, NOTE:, REF:, TEMP:
augroup HilightsForce
    autocmd!
    autocmd WinEnter,BufRead,BufNew,Syntax * :silent! call matchadd('Todo', '\(TODO\|NOTE\|REF\|TEMP\):')
    autocmd WinEnter,BufRead,BufNew,Syntax * highlight Todo guibg=Red guifg=White
augroup END


" ### terminal ### {{{
if has('terminal')
        set termguicolors
endif
"}}}
"}}}

" ### encoding ### {{{
" 文字コードの自動認識
set fileencodings=utf-8,utf-16,cp932,iso-2022-jp,euc-jp,sjis
set fileformats=unix,dos,mac
" ファイルに保存される文字エンコーディング
set fileencoding=utf-8
" 改行文字
set fileformat=unix
set ambiwidth=double
" テキスト挿入中の自動折り返しを日本語に対応させる
" auto commet off
autocmd MyAutoCmd BufEnter * setlocal formatoptions=tcqmM
" }}}

" ### Indent ###{{{
set autoindent " 新しい行のインデントを継続する
set expandtab "tab to space
set tabstop=4 " 画面上でタブ文字の占める幅
set shiftwidth=4 " 自動インデントでずれる幅
set smartindent
" 折り返しの際にインデントを考慮
if exists('+breakindent')
        set breakindent
endif
" }}}

" ### search ### {{{
" インクリメンタル検索を有効にする
set incsearch
" 大文字小文字を無視
set ignorecase
" 大文字が入力されたら大文字小文字を区別する
set smartcase
" }}}

" マウスとの連携機能を On にする
set mouse=a
set ttymouse=xterm2

" ### Buffer ### {{{
" if miss to guess filetype
autocmd MyAutoCmd BufWritePost *
                        \ if &filetype ==# '' && exists('b:ftdetect') |
                        \ unlet! b:ftdetect |
                        \ filetype detect |
                        \ endif

" Enable cursorline at needed
augroup vimrc-auto-cursorline
        autocmd!
        autocmd CursorMoved,CursorMovedI * call s:auto_cursorline('CursorMoved')
        autocmd CursorHold,CursorHoldI * call s:auto_cursorline('CursorHold')
        autocmd WinEnter * call s:auto_cursorline('WinEnter')
        autocmd WinLeave * call s:auto_cursorline('WinLeave')
        let s:cursorline_lock = 0
        function! s:auto_cursorline(event)
                if a:event ==# 'WinEnter'
                        setlocal cursorline
                        let s:cursorline_lock = 2
                elseif a:event ==# 'WinLeave'
                        setlocal nocursorline
                elseif a:event ==# 'CursorMoved'
                        if s:cursorline_lock
                                if 1 < s:cursorline_lock
                                        let s:cursorline_lock = 1
                                else
                                        setlocal nocursorline
                                        let s:cursorline_lock = 0
                                endif
                        endif
                elseif a:event ==# 'CursorHold'
                        setlocal cursorline
                        let s:cursorline_lock = 1
                endif
        endfunction
augroup END

" vimの無名レジスタとOSのクリップボードを連携させる
if has('clipboard')
        set clipboard=unnamed,autoselect
endif

" ファイル内容が変更されると自動読み込みする
set autoread
autocmd MyAutoCmd WinEnter * checktime

if has('persistent_undo')
    if !isdirectory(expand('$HOME/.vim/.undo'))
        call mkdir(expand('$HOME/.vim/.undo'), 0700)
    endif
    set undodir=$HOME/.vim/.undo
    set undofile
endif
" no viminfo file
set viminfo='50,/50,:25,n$HOME/.vim/viminfo
" バックアップファイルの出力先を変更
set nobackup
" スワップファイルを作成しない
set noswapfile

" title
set title

" 不可視文字を不可視化
set nolist
" 自動折り返ししない
set textwidth=0
" 長い行を@にさせない
set display=lastline
" 最低でも上下に表示する行数
set scrolloff=5

" 入力したコマンドを画面下に表示
set showcmd

" ステータスラインを表示
set laststatus=2
set statusline=[.%F%r%h%w%m]%=
set statusline+=%{'['.(&fenc!=''?&fenc:&enc).']['.&fileformat.']'}
set ruler " add cursor line location in right of status line

" disable conceal for tex
let g:tex_conceal=''
autocmd MyAutoCmd FileType latex :setlocal foldmethod=marker

autocmd MyAutoCmd BufWritePre * call s:remove_unnecessary_space()
function! s:remove_unnecessary_space()
        " delete last spaces
        %s/\s\+$//ge
        " delete last blank lines
        while getline('$') == ""
                $delete _
        endwhile
endfunction

" colorscheme
colorscheme iceberg
syntax enable

autocmd MyAutoCmd FileType help call s:set_japanese_document_format()
function! s:set_japanese_document_format()
        " change important keyword the last of lines ' >' and the top of lines '<'
        if &buftype != 'help'
                hi ignore ctermfg=red
                syntax match Error /\%>79v.*/
                syntax match Error /、\s/
                syntax match Error /。\s/
                set cc=+1
                let JpCountOverChars = 1
                set formatexpr=jpfmt#formatexpr()
                if has('conceal')
                        setlocal conceallevel=0
                endif
        endif
endfunction

set nohlsearch
if v:version > 800
        set nrformats=alpha,hex,bin
endif
" }}}

" ### Diff ### {{{
set diffexpr=MyDiff()
function! MyDiff()
        let opt = ""
        if &diffopt =~ "icase"
                let opt = opt . "-i "
        endif
        if &diffopt =~ "iwhile"
                let opt = opt . "-b "
        endif
        silent execute "!diff -a --binary " . opt . v:fname_in . " " . v:fname_new . " > " . v:fname_out
endfunction
" }}}

" ### completion ### {{{
" 入力補完機能を有効化
set wildmenu wildmode=longest:full
set completeopt=menu,preview

" spelling補完 on <C-x><C-s>
set spelllang+=cjk " 日本語をスペルチェックの対象 から除外する

" tag Complete For html and xml file
augroup xml-html-comp
    autocmd!
    autocmd FileType html,xml inoremap <buffer> </ </<C-x><C-o>
augroup END

" dictionary Complete
augroup dict-comp
    autocmd!
    autocmd FileType javascript :setlocal dictionary=$HOME/.vim/dict/javascript.dict
    autocmd FileType html :setlocal dictionary=$HOME/.vim/dict/html.dict
    autocmd FileType css :setlocal dictionary=$HOME/.vim/dict/css.dict
    autocmd FileType latex :setlocal dictionary=$HOME/.vim/dict/tex.dict
    autocmd FileType python :setlocal dictionary=$HOME/.vim/dict/python.dict
    autocmd FileType cpp :setlocal dictionary=$HOME/.vim/dict/cpp.dict
    autocmd FileType c :setlocal dictionary=$HOME/.vim/dict/clang.dict
    autocmd FileType ruby :setlocal dictionary=$HOME/.vim/dict/ruby.dict
    autocmd FileType php :setlocal dictionary=$HOME/.vim/dict/php.dict
augroup END

" syntastic check disabled by lsp
let g:lsp_diagnostics_enabled = 0
let g:lsp_use_event_queue = 1

if executable('go-langserver')
    augroup LspGo
        autocmd!
        autocmd User lsp_setup call lsp#register_server({
                    \ 'name': 'go-langserver',
                    \ 'cmd': {server_info->['go-langserver', '-gocodecompletion']},
                    \ 'whitelist': ['go'],
                    \ })
    augroup END
endif

" use directory with .git as root
if executable('typescript-language-server')
    augroup LspJSTS
        autocmd!
        autocmd User lsp_setup call lsp#register_server({
                    \ 'name': 'javascript support using typescript-language-server',
                    \ 'cmd': { server_info->[&shell, &shellcmdflag, 'typescript-language-server --stdio']},
                    \ 'root_uri' : { server_info->lsp#utils#path_to_uri(lsp#utils#find_nearest_parent_directory(lsp#utils#get_buffer_path(), '.git/..'))},
                    \ 'whitelist' : ['javascript', 'javascript.jsx']
                    \ })
    augroup END
endif

if executable('solagraph')
    " gem install solagraph
    augroup LspRuby
        autocmd!
        autocmd User lsp_setup call lsp#register_server({
                    \ 'name': 'solagraph',
                    \ 'cmd': {server_info->[&shell, &shellcmdflag, 'solagraph stdio']},
                    \ 'initialization_options': { "diagnostics": "true"},
                    \ 'whitelist': ['ruby'],
                    \ })
    augroup END
endif

if executable('css-languageserver')
    " npm install -g vscode-css-languageserver-bin
    augroup LspCSS
        autocmd!
        autocmd User lsp_setup call lsp#register_server({
                    \ 'name': 'css-languageserver',
                    \ 'cmd': {server_info->[&shell, &shellcmdflag, 'css-languageserver --stdio']},
                    \ 'whitelist': ['css', 'less', 'sass'],
                    \ })
    augroup END
endif

" npm install -g intelephense-server
" npm list -g | head
autocmd User lsp_setup call lsp#register_server({
            \ 'name': 'intelephense',
            \ 'cmd': {server_info->['node', expand('~/.nvm/versions/node/v11.7.0/lib/node_modules/intelephense-server/lib/server.js'), '--stdio']},
            \ 'whitelist': ['php'],
            \ })

" set omni function if don't have completion tools by plugin
if &l:omnifunc == ''
    augroup omni-comp
        autocmd!
        setlocal omnifunc=syntaxcomplete#Complete
        autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
        autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
        autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
        autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
        autocmd FileType python setlocal omnifunc=python3complete#Complete
        autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
        autocmd FileType c setlocal omnifunc=ccomplete#Complete
        autocmd FileType php setlocal omnifunc=phpcomplete#Complete
    augroup END
endif
" }}}

" ### Command ### {{{
" the count of command history
set history=2000
" いろんなコマンドの後にカーソルを先頭に移動させない
set nostartofline

" generate random string
command! -nargs=1 GenerateRandomStr call s:generate_random_str(<f-args>)
function! s:generate_random_str(size) abort
    let s:str=sha256(reltimestr(reltime()))[:(a:size) -1]
    let s:pos = getpos('.')
    execute ":normal i" . s:str
endfunction

" ### For Proxy Setting ### {{{
" Setting File For Proxy
" For example
"
" {
"   name: {
"     http: http://proxy.aa.bb:8080,
"     https: https://proxy.aa.bb:8080
"   }
" }
"
" git などのproxyを設定する。
command! -nargs=1 ProxySet call s:set_proxy(<f-args>)
command! ProxyUnset call s:unset_proxy()
let s:readfile=expand('~/.vim_proxy_setting.json')
if filereadable(s:readfile)
    " string型としてファイルを読み込む
    let s:lines=join(readfile(s:readfile, '', 10))
    " json形式へ変換
    let s:proxy_json=json_decode(s:lines)

    function! s:set_proxy(name) abort
        if has_key(s:proxy_json, a:name)
            if has_key(s:proxy_json[a:name], 'http')
                let s:http_proxy=s:proxy_json[a:name]["http"]
                let $http_proxy=s:http_proxy

                call system("git config --global http.proxy " . s:http_proxy )
                call system("npm config -g set proxy " . s:http_proxy )
                " Set ssh proxy
                " ~/.ssh/configの設定に書き込む
            endif

            if has_key(s:proxy_json[a:name], 'https')
                let s:https_proxy=s:proxy_json[a:name]["https"]
                let $https_proxy=s:https_proxy

                call system("git config --global https.proxy " . s:https_proxy )
                call system("npm config -g set https-proxy " . s:https_proxy )

                " Set ssh proxy
                " ~/.ssh/configの設定に書き込む
            endif
        endif
    endfunction

    function! s:unset_proxy() abort
        " unset system proxy setting
        unlet $http_proxy
        unlet $https_proxy

        " unset git global proxy setting
        call system("git config --global --unset http.proxy")
        call system("git config --global --unset https.proxy")
    endfunction
else
    echomsg "Not found '~/.vim_proxy_setting.json'"
endif
" }}}
" }}}
" }}}
" }}}

" ### key mapping ### {{{
" Wait key time
set timeout ttimeoutlen=50
" change Leader key to Space key
let mapleader = "\<Space>"
" return command line history
cnoremap <C-n> <Down>
" proceed commadn line history
cnoremap <C-p> <Up>
" disable not to save and close
nnoremap ZQ <Nop>
" when tap :wq, make not save and close if buffer is no difference before
cnoremap wq x
" }}}

" ### Ruby setting ### {{{
autocmd MyAutoCmd FileType ruby :setlocal isk+=@-@
" }}}

" ### plugin ### {{{
" vim-plug {{{
" automated install vim-plug
let s:vim_plug_url='https://github.com/junegunn/vim-plug'
if !filereadable(expand('$HOME/.vim/vim-plug/plug.vim'))
    call system("git clone " . s:vim_plug_url . " " . $HOME . "/.vim/vim-plug/")
endif
source ~/.vim/vim-plug/plug.vim
call plug#begin('~/.vim/plugged')
" For Completion and Snippet
Plug 'Shougo/neosnippet.vim'
Plug 'Shougo/neosnippet-snippets'
Plug 'mattn/sonictemplate-vim'
Plug 'tpope/vim-surround'

" For Code Check
Plug 'w0rp/ale'

Plug 'majutsushi/tagbar'

" Language Server Protocol
Plug 'prabirshrestha/async.vim'
Plug 'prabirshrestha/vim-lsp'

" For Golang
Plug 'fatih/vim-go', { 'for' : 'go', 'do': ':GoInstallBinaries' }

" For javascript
Plug 'ryanolsonx/vim-lsp-javascript', { 'for' : 'js' }

" For Clang
Plug 'homedm/cinclude.vim', { 'for': 'c' }
Plug 'justmao945/vim-clang'
" Plug 'homedm/gilo.vim'

" For writing
Plug 'mbbill/undotree' " :UndotreeToggle

" Runner
Plug 'thinca/vim-quickrun', {}

" ColorScheme
Plug 'cocopon/iceberg.vim', {'do': 'cp colors/* ~/.vim/colors/'}
Plug 'altercation/solarized', {'do': 'cp vim-colors-solarized/colors/* ~/.vim/colors/'}

" For Format
Plug 'vim-scripts/autodate.vim', {}
Plug 'fuenor/JpFormat.vim', {}
Plug 'vim-scripts/Align'

" For Plugin
Plug 'mopp/layoutplugin.vim'

"Draw image
Plug 'thinca/vim-painter'
call plug#end()
" }}}
" match {{{
let g:loaded_matchparen = 1
set showmatch
set matchpairs+=「:」,（:）
" expand % command
if has('packages')
    packadd! matchit " if has package function, read /pack/.../matchit.vim
else
    runtime! macros/matchit.vim
endif
" }}}

" tagbar.vim
let g:tagbar_width = 30

" code checker plugin
" ale {{{
if has('job') && has('channel') && has('timers')
    let g:ale_sign_column_always = 1
    let g:ale_list_window_size = 2
    " format message
    let g:ale_echo_msg_error_str = 'E'
    let g:ale_echo_msg_warning_str = 'W'
    let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'
    " move error mapping
    nmap <silent> <C-k> <plug>(ale_next_wrap)
    " check at :w
    let g:ale_lint_on_save = 1
    let g:ale_lint_on_text_changed = 'never'
    " Disable check at file open
    let g:ale_lint_on_enter = 0
    " use QuickFix instead of location list
    let g:ale_set_loclist = 0
    let g:ale_set_quickfix = 1

    " for npm local installed eslint and textlint
    if filereadable(expand('$PWD/.textlintrc')) ||
                \ filereadable(expand('$PWD/.eslintrc.json'))
        let $PATH .= ':' . $PWD . 'node_modules/.bin'
    endif
    " set linter
    let g:ale_linters = {
                \ 'markdown' : ['textlint'],
                \ 'javascript' : ['eslint'],
                \ 'html' : ['cHTMLHint'],
                \ 'css' : ['csslint'],
                \ 'latex' : ['chktex'],
                \ 'c' : ['gcc'],
                \ 'cpp' : ['gcc'],
                \ 'java': [],
                \ }
    autocmd MyAutoCmd BufNewFile,BufRead *.cpp call s:cpplinter()
    autocmd MyAutoCmd BufNewFile,BufRead *.c call s:clanglinter()
    function! s:cpplinter()
        let g:ale_cpp_gcc_options="-std=c++17 -Wall"
    endfunction
    function! s:clanglinter()
        let g:ale_c_gcc_options="-std=c99 -Wall"
    endfunction
    " set fixer
    nmap <space>= :ALEFix<CR>
endif
" }}}

" QuickRun.vim {{{
nnoremap <expr><silent> <space>c quickrun#is_runnting() ? quickrun#sweep_sessions() "\<C-c>"
" <Leader>qでquickrunで開かれた出力バッファを閉じる
nnoremap <Leader>q :<C-u>bw! \[QuickRun\ Output\]<CR>
let g:quickrun_config = {
            \ '_' : {
            \   'outputter/buffer/split' : ':botright 8sp',
            \   'outputter/buffer/close_on_empty' : 1,
            \   'outputter/buffer/name' : '[QuickRun Output]',
            \ },
            \ 'c/gcc' : {
            \   'cmdopt' : '-stc=c99 -Wall'
            \ },
            \ 'tex' : {
            \   'command' : 'lualatex',
            \   'exec' : ['%c -synctex=1 -interaction=nonstopmode %s', 'apvlv %s:r.pdf']
            \ },
            \ }
" }}}

" neosnippet {{{
" plugin key-mappings.
if v:version > 704
    " Enable snipMate compatibility feature.
    let g:neosnippet#enable_snipmate_compatibility = 1
    " Tell Neosnippet about the My Snippets Directory
    " My snippets files
    let g:neosnippet#snippets_directory=['~/.vim/snippets/']
    " set key map for snippet
    imap <C-k> <plug>(neosnippet_expand_or_jump)
    smap <C-k> <plug>(neosnippet_expand_or_jump)
    xmap <C-k> <plug>(neosnippet_expand_target)
    smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
                \ "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
    if has('conceal')
        set conceallevel=2 concealcursor=niv
    endif
endif
" }}}

" sonictemplate-vim.vim {{{
" Tell My Template Directory
let g:sonictemplate_vim_template_dir = [
            \ '~/.vim/template'
            \]
" }}}

" Align.vim {{{
" Setting for japanese environment
let g:Align_xstrlen = 3
" }

" JpFormat.vim {{{
" gqコマンドを実行前に自動整形をオフにする
nnoremap <silent> <expr> gq JpFormat_cmd("gq")
" .txt, .mdで自動整形を有効にする。
autocmd MyAutoCmd FileType markdown call s:set_autoformat()
autocmd MyAutoCmd FileType text call s:set_autoformat()
function! s:set_autoformat()
    let JpCountChars=80
    let JpCountOverChars=1
    set formatexpr=jpfmt#formatexpr()
endfunction
" }}}
" autodate.vim {{{
let autodate_format="%d/%m/%Y\ -\ %H:%M:%S"
" }}}
autocmd! MyAutoCmd FileType latex,tex,markdown :UndotreeToggle
" }}}

set secure
